# TASK-022: День 22 — Ассистент поддержки (Telegram) с RAG + MCP (CRM JSON)

## Статус: `todo`

## Цель

Сделать мини-сервис “ассистент поддержки”, который отвечает на вопросы пользователей о продукте **с учётом контекста тикета**:
- **RAG**: ответы опираются на документацию/FAQ (источники + ссылки на файлы).
- **MCP**: интеграция с “CRM” (MVP: локальный JSON с пользователями/тикетами; затем MCP server, чтобы агент мог читать/обновлять тикеты инструментами).
- Интерфейс: **Telegram-бот** (по токену из `.env`), который принимает вопросы и/или `ticket_id`.

Пример: “Почему не работает авторизация?” → ассистент отвечает, учитывая поля тикета (пользователь, устройство, ошибки, статус, последние события), + использует знания из FAQ/доков через RAG.

## Контекст репозитория (что уже есть)

- Есть RAG инфраструктура: `mcp/rag-server/` + slash-команды `.claude/commands/rag/*`.
- Есть MCP примеры: `mcp/reminder/`, `mcp/docker-runner/`, `mcp/location-tracker/`.
- Есть интеграция LLM через OpenRouter в `gemini-client/` (в `.env.example`: `OPENROUTER_API_KEYS`, `OPENROUTER_BASE_URL`, `OPENROUTER_MODEL`).

## Важное про секреты

- **НЕ коммитить Telegram токен** в репозиторий.
- Токен Telegram-бота и ключ(и) OpenRouter должны быть только в `.env` (локально).

Рекомендуемые переменные:
- `TELEGRAM_BOT_TOKEN=<your_token>`
- `OPENROUTER_API_KEYS=...` (как в `.env.example`)
- `OPENROUTER_MODEL=...` (как в `.env.example`)

## MVP архитектура

### Компоненты

1) **Telegram Bot** (polling):
   - Команда `/start` — краткая справка.
   - Команда `/ticket <id>` — выбрать тикет в контекст.
   - Любое сообщение — вопрос; если тикет выбран, учитывать его контекст.

2) **Support Assistant Service** (Python, внутри `backend/` или отдельный модуль):
   - Вход: `question`, `ticket_context?`, `user_context?`.
   - Шаг 1: нормализация/классификация (например: auth/billing/bug/howto).
   - Шаг 2: RAG поиск по докам/FAQ через существующий `rag_search`.
   - Шаг 3: генерация ответа через OpenRouter (LLM).
   - Выход: “короткий ответ + шаги диагностики + что нужно от пользователя + источники”.

3) **CRM (MVP: JSON)**:
   - Файл(ы) в репо (пример): `data/crm/users.json`, `data/crm/tickets.json`.
   - Доступ:
     - MVP: чтение JSON напрямую из сервиса (без MCP).
     - Затем: MCP server `mcp/crm-json/` с инструментами `get_ticket`, `list_tickets`, `update_ticket` (опционально).

### Поток (RAG + тикет)

1) Telegram: пользователь спрашивает → бот формирует `question` + `ticket_id?`.
2) CRM lookup: получить тикет по `ticket_id` (или попросить выбрать тикет).
3) Собрать “контекст тикета” (кратко, структурировано):
   - продукт/план, платформа, версия приложения
   - текст проблемы, шаги воспроизведения, ошибки/скриншот-текст
   - последние действия: login/signup/reset, смена устройства, VPN, 2FA, email link
   - статус тикета и история сообщений
4) Сформировать RAG запрос:
   - `"{problem_category}: {question}. ticket_context: {key_fields}. possible causes? troubleshooting steps?"`
5) Вызвать `rag_search` → взять top-k (например 5–10).
6) LLM: сгенерировать ответ, строго опираясь на:
   - тикет контекст,
   - RAG сниппеты (как источники),
   - запрет на выдумывание: если данных недостаточно — попросить уточнения.

## Формат ответа (рекомендация)

1) **Краткий вывод** (1–2 предложения)
2) **Проверки (шаги 1..N)**: конкретные действия, что посмотреть/сделать
3) **Если не помогло**: что запросить у пользователя (логи/скрин/точная ошибка)
4) **Статус тикета** (если есть): “вижу тикет #..., статус ..., последнее сообщение ...”
5) **Источники**: список `file_path` из RAG (и/или FAQ ID), без раскрытия секретов

## Схемы данных (CRM JSON) — MVP

### `users.json` (пример)

```json
[
  {
    "id": "u_1001",
    "email": "user@example.com",
    "plan": "pro",
    "created_at": "2026-01-01T12:00:00Z",
    "tags": ["beta", "b2c"]
  }
]
```

### `tickets.json` (пример)

```json
[
  {
    "id": "t_2001",
    "user_id": "u_1001",
    "subject": "Не работает авторизация",
    "status": "open",
    "priority": "high",
    "channel": "telegram",
    "product_area": "auth",
    "created_at": "2026-01-10T10:00:00Z",
    "last_updated_at": "2026-01-10T10:30:00Z",
    "context": {
      "platform": "ios",
      "app_version": "1.4.2",
      "error_text": "Invalid session",
      "steps_tried": ["reset_password"],
      "notes": "Началось после смены устройства"
    },
    "messages": [
      { "from": "user", "at": "2026-01-10T10:00:00Z", "text": "Не могу войти..." },
      { "from": "support", "at": "2026-01-10T10:10:00Z", "text": "Уточните..." }
    ]
  }
]
```

## MCP “CRM JSON” (следующий шаг после MVP)

Сервер `mcp/crm-json/` (Node + `@modelcontextprotocol/sdk`, как `mcp/reminder/`), инструменты:
- `get_user(id | email)`
- `get_ticket(id)`
- `list_tickets(filter?)` (status/user_id/product_area)
- `add_ticket(message)` (опционально)
- `update_ticket(id, patch)` (опционально; для статусов/тегов/notes)

Регистрация в `.mcp.json` отдельным блоком `crm-json`.

## Deliverables

1) Telegram-бот (код + инструкция запуска)
2) Сервис “support assistant” (RAG + LLM + формат ответа)
3) Набор FAQ/доков для индексации RAG (минимум: `docs/support-faq.md`)
4) CRM JSON dataset (MVP) + (опционально) MCP server `mcp/crm-json/`
5) Документация: как запустить, как добавить/обновить FAQ, как проверить

## Acceptance Criteria

- [ ] Бот отвечает на общий вопрос без тикета (используя RAG) и возвращает “Источники”
- [ ] Бот отвечает на вопрос **с тикетом** и явно учитывает поля тикета (платформа/ошибка/шаги)
- [ ] Если данных недостаточно — задаёт 1–3 уточняющих вопроса вместо “галлюцинаций”
- [ ] Есть минимум 5 FAQ статей (в т.ч. “авторизация не работает”)
- [ ] Индекс RAG не пустой (`/rag:status` показывает документы)
- [ ] Секреты не попадают в git (токены/ключи только в `.env`)

## Приоритет: `high`

